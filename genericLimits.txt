1. нельзя использовать внутри дженирика new, то есть нельзя выделять память,
потому что компилятор не знает, какого типа мы собираемся создавать объект.
тип можно передать извне
<T> void A(T[]n) - тип получен из объекта (массив)
но нельзя T[] у = new T(10); - это неправильно 


2. внутри нельзя использовать защищенную память static, тк дженерик динамичный

3. ошибка неоднозначности - методы нельзя называть одинаково
Class<T, V>
{
    T object1;
    V object2;
    voic set(T o) {
        this.ob = 0;
    }
    void set(V o) {this.object2 = 0;}
}